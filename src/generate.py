def get_ijk_list(m):
    l = []
    for a in range(1, m + 2):
        for b in range(1, a + 1):
            i = m + 1 - a
            j = a - b
            k = b - 1
            l.append([i, j, k])
    return l


def test_get_ijk_list():
    assert get_ijk_list(3) == [[3, 0, 0], [2, 1, 0], [2, 0, 1], [1, 2, 0], [1, 1, 1], [1, 0, 2], [0, 3, 0], [0, 2, 1], [0, 1, 2], [0, 0, 3]]


def print_line(exp, geo, m, r):

    _exp = exp[:]
    _exp[m] -= 1

    vec_r = 'buffer[OFFSET_%02d_%02d_%02d_%i%i%i]' % (exp[0], exp[1], exp[2], geo[0], geo[1], geo[2])
    vec_p = '%s' % r
    vec_a = 'buffer[OFFSET_%02d_%02d_%02d_%i%i%i]' % (_exp[0], _exp[1], _exp[2], geo[0], geo[1], geo[2])

    if (geo[m] > 0):
        geo_right = geo[:]
        geo_right[m] -= 1
        vec_b = 'buffer[OFFSET_%02d_%02d_%02d_%i%i%i]' % (_exp[0], _exp[1], _exp[2], geo_right[0], geo_right[1], geo_right[2])
        if geo[m] > 1:
            return 'get_pa_plus_sb_block(&{0}, {1}, {2}.0, &{3}, &{4});'.format(vec_a, vec_p, geo[m], vec_b, vec_r)
        else:
            return 'get_pa_plus_b_block(&{0}, {1}, &{2}, &{3});'.format(vec_a, vec_p, vec_b, vec_r)
    else:
        return 'get_pa_block(&{0}, {1}, &{2});'.format(vec_a, vec_p, vec_r)


def test_print_line():
    s = print_line([1, 1, 1], [1, 1, 1], 2, 'py')
    assert s == 'get_pa_plus_b_block(&buffer[OFFSET_01_01_00_111], py, &buffer[OFFSET_01_01_00_110], &buffer[OFFSET_01_01_01_111]);'


def get_ao_pointer_prefix(geo):
    return 'ao_{0}{1}{2}'.format(geo[0], geo[1], geo[2])


def get_offsets(max_l_value, ao_chunk_length, max_geo_diff_order):
    s = []
    s.append('#ifndef OFFSETS_H_INCLUDED')
    s.append('#define OFFSETS_H_INCLUDED')
    s.append('')
    offset = 0
    for l in range(0, max_l_value + 1):
        for exp in get_ijk_list(l):
            for g in range(0, max_geo_diff_order + 1):
                for geo in get_ijk_list(g):
                    s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                    s.append('#define OFFSET_%02d_%02d_%02d_%s %i' % (exp[0], exp[1], exp[2], s_geo, offset))
                    offset += ao_chunk_length
    s.append('')
    s.append('#define BUFFER_LENGTH {0}'.format(offset))
    s.append('')
    s.append('#endif // OFFSETS_H_INCLUDED')
    return '\n'.join(s)


def test_get_offsets():
    s = '''#ifndef OFFSETS_H_INCLUDED
#define OFFSETS_H_INCLUDED

#define OFFSET_00_00_00_000 0
#define OFFSET_00_00_00_100 32
#define OFFSET_00_00_00_010 64
#define OFFSET_00_00_00_001 96
#define OFFSET_01_00_00_000 128
#define OFFSET_01_00_00_100 160
#define OFFSET_01_00_00_010 192
#define OFFSET_01_00_00_001 224
#define OFFSET_00_01_00_000 256
#define OFFSET_00_01_00_100 288
#define OFFSET_00_01_00_010 320
#define OFFSET_00_01_00_001 352
#define OFFSET_00_00_01_000 384
#define OFFSET_00_00_01_100 416
#define OFFSET_00_00_01_010 448
#define OFFSET_00_00_01_001 480

#define BUFFER_LENGTH 512

#endif // OFFSETS_H_INCLUDED'''
    assert get_offsets(1, 32, 1) == s


def write_routine(_maxg, file_name, max_l_value, ao_chunk_length, max_geo_diff_order):
    import cs_trans

    cs = cs_trans.get_cs_trans(max_l_value)

    sfoo = '''
//  this file is automatically generated by generate.py

#include <iostream>
#include <cstdlib>
#include <math.h>
#include <stdio.h>
#include <cstring>

#include "autogenerated.h"
#include "offsets.h"
#include "ao_vector.h"
          \n'''

    s = '''void get_ao_g%i(const int    shell_l_quantum_numbers,
               const int    num_primitives,
               const bool   is_spherical,
               const double primitive_exponents[],
               const double contraction_coefficients[],
               const int    num_points,
                     double s[],
                     double buffer[],
               const double shell_centers_coordinates[],
               const double extent_squared,
               const double pw[],
                     double px[],
                     double py[],
                     double pz[],
                     double p2[],\n''' % _maxg

    l = []
    for g in range(0, _maxg + 1):
        for geo in get_ijk_list(g):
            l.append('double ao_%i%i%i[]' % (geo[0], geo[1], geo[2]))

    for i in range(len(l)):
        if i < len(l) - 1:
            s += '                     %s,\n' % l[i]
        else:
            s += '                     %s)' % l[i]

    sfoo += '''
%s
{
         \n''' % (s)

    if _maxg > 0:
        for i in range(_maxg + 1):
            sfoo += '    double fx_%i;\n' % i
            sfoo += '    double fy_%i;\n' % i
            sfoo += '    double fz_%i;\n' % i
    sfoo += '    double a;\n'
    sfoo += '    double c;\n\n'

    sfoo += '        get_p2_block(shell_centers_coordinates,\n'
    sfoo += '                     pw,\n'
    sfoo += '                     px,\n'
    sfoo += '                     py,\n'
    sfoo += '                     pz,\n'
    sfoo += '                     p2);\n\n'

    sfoo += '        // screening\n'
    sfoo += '        if (not calculate_chunk_block(extent_squared, p2)) return;\n\n'

    array = 'buffer[OFFSET_00_00_00_000]'
    sfoo += '        memset(&%s, 0, %i*sizeof(double));\n' % (array, ao_chunk_length)
    for g in range(1, _maxg + 1):
        for geo in get_ijk_list(g):
            array = 'buffer[OFFSET_00_00_00_%i%i%i]' % (geo[0], geo[1], geo[2])
            sfoo += '        memset(&%s, 0, %i*sizeof(double));\n' % (array, ao_chunk_length)

    sfoo += '''
        for (int i = 0; i < num_primitives; i++)
        {
            a = -primitive_exponents[i];
            c = contraction_coefficients[i];

            get_exp_block(p2, c, a, s);

            #pragma ivdep
            #pragma vector aligned
            for (int k = 0; k < %i; k++)
            {
                buffer[OFFSET_00_00_00_000 + k] += s[k];
              \n''' % ao_chunk_length

    if (_maxg > 0):
        sfoo += '''                fx_0 = 1.0;
                fy_0 = 1.0;
                fz_0 = 1.0;
                fx_1 = 2.0*a*px[k];
                fy_1 = 2.0*a*py[k];
                fz_1 = 2.0*a*pz[k];
                buffer[OFFSET_00_00_00_100 + k] += fx_1*s[k];
                buffer[OFFSET_00_00_00_010 + k] += fy_1*s[k];
                buffer[OFFSET_00_00_00_001 + k] += fz_1*s[k];
                  \n'''

    for g in range(2, _maxg + 1):
        sfoo += '                fx_%i = fx_%i*fx_1 + %i.0*a*fx_%i;\n' % (int(g), int(g - 1), int(g - 1) * 2, int(g - 2))
        sfoo += '                fy_%i = fy_%i*fy_1 + %i.0*a*fy_%i;\n' % (int(g), int(g - 1), int(g - 1) * 2, int(g - 2))
        sfoo += '                fz_%i = fz_%i*fz_1 + %i.0*a*fz_%i;\n' % (int(g), int(g - 1), int(g - 1) * 2, int(g - 2))
        for geo in get_ijk_list(g):
            sfoo += '                buffer[OFFSET_00_00_00_%i%i%i + k] += fx_%i*fy_%i*fz_%i*s[k];\n' \
                    % (geo[0], geo[1], geo[2],
                       geo[0], geo[1], geo[2])
    sfoo += '            }\n'
    sfoo += '        }\n'

    for l in range(0, max_l_value + 1):
        sfoo += '\n        if (shell_l_quantum_numbers == ' + '%i)\n' % l
        sfoo += '        {\n'
        if l < 2:
            c = 0
            for exp in get_ijk_list(l):
                for s in range(len(cs[l][c])):
                    f = cs[l][c][s]
                    if abs(f) > 0.0:
                        for g in range(0, _maxg + 1):
                            for geo in get_ijk_list(g):
                                s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                                sfoo += '            memcpy(&%s[%i*num_points], &buffer[OFFSET_%02d_%02d_%02d_%s], %i*sizeof(double));\n' % (get_ao_pointer_prefix(geo), s, exp[0], exp[1], exp[2], s_geo, ao_chunk_length)
                c += 1
        else:
            sfoo += '            if (is_spherical)\n'
            sfoo += '            {\n'
            c = 0
            for exp in get_ijk_list(l):
                for s in range(len(cs[l][c])):
                    f = cs[l][c][s]
                    if abs(f) > 0.0:
                        for g in range(0, _maxg + 1):
                            for geo in get_ijk_list(g):
                                s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                                sfoo += '                vec_daxpy_block(%20.16e, &buffer[OFFSET_%02d_%02d_%02d_%s], &%s[%i*num_points]);\n' % (f, exp[0], exp[1], exp[2], s_geo, get_ao_pointer_prefix(geo), s)
                c += 1
            sfoo += '            }\n'
            sfoo += '            else\n'
            sfoo += '            {\n'
            s = 0
            for exp in get_ijk_list(l):
                for g in range(0, _maxg + 1):
                    for geo in get_ijk_list(g):
                        s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                        sfoo += '                memcpy(&%s[%i*num_points], &buffer[OFFSET_%02d_%02d_%02d_%s], %i*sizeof(double));\n' % (get_ao_pointer_prefix(geo), s, exp[0], exp[1], exp[2], s_geo, ao_chunk_length)
                s += 1
            sfoo += '            }\n'
        sfoo += '            return;\n'
        sfoo += '        }\n'
        sfoo += '        else\n'
        sfoo += '        {\n'
        if l + 1 < max_l_value + 1:
            for exp in get_ijk_list(l + 1):
                for g in range(0, _maxg + 1):
                    for geo in get_ijk_list(g):
                        if exp[0] > 0:
                            sfoo += print_line(exp, geo, 0, 'px') + '\n'
                        else:
                            if exp[1] > 0:
                                sfoo += print_line(exp, geo, 1, 'py') + '\n'
                            else:
                                if exp[2] > 0:
                                    sfoo += print_line(exp, geo, 2, 'pz') + '\n'
        else:
            sfoo += '             std::cout << "error: order too high";\n'
            sfoo += '             exit(1);\n'
        sfoo += '        }\n'
    sfoo += '\n}\n'

    with open(file_name, 'w') as f:
        f.write(sfoo)


def write_aocalls(file_name, max_geo_diff_order):

    with open(file_name, 'w') as f:

        s1 = '''              shell_l_quantum_numbers[ishell],
                  shell_num_primitives[ishell],
                  is_spherical,
                  &primitive_exponents[n],
                  &contraction_coefficients[n],
                  num_points,
                  s,
                  buffer,
                  &shell_centers_coordinates[3*ishell],
                  shell_extent_squared[ishell],
                  p_block,
                  px,
                  py,
                  pz,
                  p2,
                  &ao_local[koff + shell_off[ishell]*num_points]'''
        s3 = '''
                 );
        break;'''

        for g in range(0, max_geo_diff_order + 1):

            f.write('\ncase %i:\n' % g)
            f.write('    get_ao_g%i(\n' % g)

            s2 = s1
            if g > 0:
                j = 0
                for _g in range(1, g + 1):
                    for geo in get_ijk_list(_g):
                        j += 1
                        s2 += ',\n              &ao_local[koff + (shell_off[ishell] + %i*num_ao)*num_points]' % j

            f.write(s2)
            f.write(s3)


def write_header(file_name, max_geo_diff_order):

    with open(file_name, 'w') as f:

        f.write('#ifndef AUTOGENERATED_H_INCLUDED\n')
        f.write('#define AUTOGENERATED_H_INCLUDED\n\n')

        for g in range(0, max_geo_diff_order + 1):
            f.write('void get_ao_g%i(const int    shell_l_quantum_numbers,\n' % g)
            f.write('               const int    num_primitives,\n')
            f.write('               const bool   is_spherical,\n')
            f.write('               const double primitive_exponents[],\n')
            f.write('               const double contraction_coefficients[],\n')
            f.write('               const int    num_points,\n')
            f.write('                     double s[],\n')
            f.write('                     double buffer[],\n')
            f.write('               const double shell_centers_coordinates[],\n')
            f.write('               const double extent_squared,\n')
            f.write('               const double pw[],\n')
            f.write('                     double px[],\n')
            f.write('                     double py[],\n')
            f.write('                     double pz[],\n')
            f.write('                     double p2[]')

            s = ''
            for _g in range(g + 1):
                for geo in get_ijk_list(_g):
                    s += ',\n                     double ao_%i%i%i[]' % (geo[0], geo[1], geo[2])

            f.write(s)
            f.write('\n                  );\n')

        f.write('\n#endif // AUTOGENERATED_H_INCLUDED\n')


def main(output_directory, max_l_value, ao_chunk_length, max_geo_diff_order):
    import os

    with open(os.path.join(output_directory, 'offsets.h'), 'w') as f:
        f.write(get_offsets(max_l_value, ao_chunk_length, max_geo_diff_order))

    for g in range(0, max_geo_diff_order + 1):
        write_routine(g, os.path.join(output_directory, 'autogenerated_%i.cpp' % g), max_l_value, ao_chunk_length, max_geo_diff_order)
    write_aocalls(os.path.join(output_directory, 'aocalls.h'), max_geo_diff_order)
    write_header(os.path.join(output_directory, 'autogenerated.h'), max_geo_diff_order)


if __name__ == '__main__':
    import sys
    main(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]), int(sys.argv[4]))
