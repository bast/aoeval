#include "Basis.h"

#include <stdio.h>
#include <math.h>

#include <algorithm>
#include <iostream>
#include <assert.h>

#include "AOBatch.h"
#include "parameters.h"
#include "autogenerated.h"
#include "MemAllocator.h"
#include "offsets.h"


AOBatch::AOBatch()
{
    nullify();

    assert(AO_BLOCK_LENGTH%AO_CHUNK_LENGTH == 0);
}


AOBatch::~AOBatch()
{
    MemAllocator::deallocate(ao);

    nullify();
}


void AOBatch::nullify()
{
    ao_length = -1;
    ao = NULL;
}


void AOBatch::get_ao(const Basis &basis,
                     const bool   use_gradient,
                     const int    max_ao_geo_order,
                     const int    block_length,
                     const double p[])
{
    assert(max_ao_geo_order <= MAX_GEO_DIFF_ORDER);

//  debug
//  if (max_ao_geo_order == 1)
//  {
//      printf("use_gradient = %i\n", use_gradient);
//      printf("max_ao_geo_order = %i\n", max_ao_geo_order);
//      printf("block_length = %i\n", block_length);
//      for (int ib = 0; ib < block_length; ib++)
//      {
//          printf("grid = %e %e %e %e\n", p[ib*4 + 0],
//                                         p[ib*4 + 1],
//                                         p[ib*4 + 2],
//                                         p[ib*4 + 3]);
//      }
//  }

    int l = AO_BLOCK_LENGTH*basis.num_ao_slices*basis.num_ao_cartesian;
    if (l != ao_length) // FIXME
    {
        ao_length = l;

        size_t block_size = l;

        MemAllocator::deallocate(ao);
        ao = (double*) MemAllocator::allocate(block_size*sizeof(double));

        block_size = basis.num_ao;
    }

    std::fill(&ao[0], &ao[ao_length], 0.0);

    // FIXME can be optimized
    // we do this because p can be shorter than 4*AO_BLOCK_LENGTH
    // we pad it by very large numbers to let the code screen them away
    double p_block[4*AO_BLOCK_LENGTH];
    std::fill(&p_block[0], &p_block[4*AO_BLOCK_LENGTH], 1.0e50);
    std::copy(&p[0], &p[4*block_length], &p_block[0]);

    for (int ishell = 0; ishell < basis.num_shells; ishell++)
    {
        get_ao_shell(ishell,
                     basis,
                     ao,
                     max_ao_geo_order,
                     p_block);
    }

//  debug
//  if (max_ao_geo_order == 1)
//  {
//      for (int islice = 0; islice < 4; islice++)
//      {
//          for (int iao = 0; iao < basis.num_ao_cartesian; iao++)
//          {
//              for (int ib = 0; ib < AO_BLOCK_LENGTH; ib++)
//              {
//                  printf("%i %i %i %e\n", islice, iao, ib, ao[islice*AO_BLOCK_LENGTH*basis.num_ao_cartesian + iao*AO_BLOCK_LENGTH + ib]);
//              }
//          }
//      }
//      exit(1);
//  }
}


void AOBatch::get_ao_shell(const int        ishell,
                                const Basis &basis,
                                      double     ao_local[],
                                const int        max_ao_geo_order,
                                const double     p[])
{
    double px[AO_CHUNK_LENGTH];
    double py[AO_CHUNK_LENGTH];
    double pz[AO_CHUNK_LENGTH];
    double p2[AO_CHUNK_LENGTH];
    double s[AO_CHUNK_LENGTH];
    double buffer[BUFFER_LENGTH];

    int n = 0;
    for (int jshell = 0; jshell < ishell; jshell++)
    {
        n += basis.shell_num_primitives[jshell];
    }

    switch (max_ao_geo_order)
    {
        #include "aocalls.h"
        default:
            std::cout << "ERROR: get_ao order too high\n";
            exit(1);
            break;
    }
}


bool AOBatch::is_same_center(const int              c,
                                  const std::vector<int> &carray) const
// returns true if carray is empty (no derivatives)
{
    for (unsigned int i = 0; i < carray.size(); i++)
    {
        if (c != carray[i]) return false;
    }
    return true;
}
